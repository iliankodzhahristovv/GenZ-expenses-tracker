#!/usr/bin/env tsx
/**
 * Generate Entity Type Exports
 *
 * This script automatically generates a centralized entity-types.ts file from your
 * Supabase database.types.ts file, following community best practices for cleaner imports.
 *
 * @description
 * Instead of importing like this:
 *   `import { Database } from './database.types'`
 *   `type User = Database['public']['Tables']['users']['Row']`
 *
 * You can import like this:
 *   `import { UserEntity, UserInsert, UserUpdate } from './entity-types'`
 *
 * @usage
 *   pnpm generate:types
 *   npx tsx scripts/generate-entity-types.ts
 *
 * @author Clean Architecture Template
 */

import * as fs from "fs";
import * as path from "path";

interface Config {
  /** Path to the input database.types.ts file */
  readonly databaseTypesPath: string;
  /** Path to the output entity-types.ts file */
  readonly outputPath: string;
  /** Whether to include Insert types */
  readonly includeInsertTypes: boolean;
  /** Whether to include Update types */
  readonly includeUpdateTypes: boolean;
  /** Custom suffix for entity names (default: Entity) */
  readonly entitySuffix: string;
}

const DEFAULT_CONFIG: Config = {
  databaseTypesPath: path.join(process.cwd(), "types/database.types.ts"),
  outputPath: path.join(process.cwd(), "types/entity-types.ts"),
  includeInsertTypes: true,
  includeUpdateTypes: true,
  entitySuffix: "Entity", // UserEntity vs User (keeps it clear)
};

/**
 * Extracts table names from the Supabase database.types.ts file
 */
function extractTableNames(content: string): string[] {
  // Find the Tables section in the Database interface
  const tablesMatch = content.match(/Tables:\s*{/);
  if (!tablesMatch) {
    throw new Error("Could not find Tables interface in database.types.ts");
  }

  const startIndex = tablesMatch.index! + tablesMatch[0].length;
  let braceCount = 1;
  let endIndex = startIndex;

  // Find the matching closing brace for Tables
  for (let i = startIndex; i < content.length && braceCount > 0; i++) {
    if (content[i] === "{") braceCount++;
    if (content[i] === "}") braceCount--;
    endIndex = i;
  }

  const tablesContent = content.substring(startIndex, endIndex);

  // Extract table names using a more robust regex
  const tableMatches = tablesContent.match(/^\s*([a-zA-Z_][a-zA-Z0-9_]*):\s*{/gm);

  if (!tableMatches) {
    throw new Error("Could not extract table names from Tables interface");
  }

  return tableMatches
    .map((match) => match.match(/^\s*([a-zA-Z_][a-zA-Z0-9_]*):/)?.[1])
    .filter(
      (name): name is string =>
        name !== undefined && !["Row", "Insert", "Update", "Relationships"].includes(name)
    );
}

/**
 * Converts snake_case table names to PascalCase entity names
 * Examples:
 *   - users -> UserEntity
 *   - user_profiles -> UserProfileEntity
 *   - project_members -> ProjectMemberEntity
 */
function generateEntityName(tableName: string, suffix = ""): string {
  return (
    tableName
      .split("_")
      .map((part) => part.charAt(0).toUpperCase() + part.slice(1))
      .join("") + suffix
  );
}

/**
 * Generates the content for the entity-types.ts file
 */
function generateEntityTypesContent(tableNames: string[], config: Config): string {
  const imports = `import type { Database } from "./database.types";`;

  const header = `
/**
 * Auto-generated Entity Types
 * 
 * This file is automatically generated from database.types.ts
 * DO NOT EDIT MANUALLY - regenerate using: pnpm generate:types
 * 
 * @description Provides clean imports for Supabase database types
 * 
 * @example
 * // Instead of:
 * // type User = Database['public']['Tables']['users']['Row']
 * 
 * // Use:
 * // import { UserEntity, UserInsert, UserUpdate } from '@/types/entity-types'
 * 
 * @tables ${tableNames.length} tables processed
 */

type Tables = Database["public"]["Tables"];
`;

  // Generate Row types (the main entity types)
  const rowTypes = tableNames
    .map((tableName) => {
      const entityName = generateEntityName(tableName, config.entitySuffix);
      return `export type ${entityName} = Tables["${tableName}"]["Row"];`;
    })
    .join("\n");

  // Generate Insert types
  const insertTypes = config.includeInsertTypes
    ? tableNames
        .map((tableName) => {
          const entityName = generateEntityName(tableName, config.entitySuffix);
          const insertName = entityName.replace(config.entitySuffix, "") + "Insert";
          return `export type ${insertName} = Tables["${tableName}"]["Insert"];`;
        })
        .join("\n")
    : "";

  // Generate Update types
  const updateTypes = config.includeUpdateTypes
    ? tableNames
        .map((tableName) => {
          const entityName = generateEntityName(tableName, config.entitySuffix);
          const updateName = entityName.replace(config.entitySuffix, "") + "Update";
          return `export type ${updateName} = Tables["${tableName}"]["Update"];`;
        })
        .join("\n")
    : "";

  // Utility types for generic access
  const utilityTypes = `
/**
 * Utility type to get any table's row type by name
 * @example EntityType<'users'> // same as UserEntity type
 */
export type EntityType<T extends keyof Tables> = Tables[T]["Row"];

/**
 * Utility type to get any table's insert type by name
 * @example InsertType<'users'> // same as UserInsert type
 */
export type InsertType<T extends keyof Tables> = Tables[T]["Insert"];

/**
 * Utility type to get any table's update type by name
 * @example UpdateType<'users'> // same as UserUpdate type
 */
export type UpdateType<T extends keyof Tables> = Tables[T]["Update"];

/**
 * Union type of all table names
 * @example TableName // 'users' | 'projects' | ...
 */
export type TableName = keyof Tables;
`;

  // Generate examples and documentation
  const examples = `
/**
 * Usage Examples:
 * 
 * \`\`\`typescript
 * // Clean imports
 * import { UserEntity, ProjectEntity } from '@/types/entity-types';
 * import { UserInsert, ProjectUpdate } from '@/types/entity-types';
 * 
 * // Repository methods
 * function createUser(data: UserInsert): Promise<UserEntity> { ... }
 * function updateProject(id: string, data: ProjectUpdate): Promise<ProjectEntity> { ... }
 * 
 * // Mappers
 * class UserMapper {
 *   static toDomain(entity: UserEntity): User { ... }
 *   static toEntity(domain: User): UserEntity { ... }
 * }
 * 
 * // No type assertions needed!
 * const { data } = await supabase.from('users').select('*');
 * // data is automatically typed as UserEntity[] | null
 * \`\`\`
 */
`;

  const tableList = `
/**
 * Generated types for ${tableNames.length} tables:
 * ${tableNames.map((name) => `* ${name} ‚Üí ${generateEntityName(name, config.entitySuffix)}`).join("\n * ")}
 */
`;

  // Combine all sections
  const sections = [imports, header, "// Row Types (Main Entity Types)", rowTypes];

  if (config.includeInsertTypes) {
    sections.push("", "// Insert Types", insertTypes);
  }

  if (config.includeUpdateTypes) {
    sections.push("", "// Update Types", updateTypes);
  }

  sections.push(utilityTypes, examples, tableList);

  return sections.join("\n");
}

/**
 * Validates that the database.types.ts file exists and is readable
 */
function validateDatabaseTypesFile(filePath: string): void {
  if (!fs.existsSync(filePath)) {
    throw new Error(
      `Database types file not found: ${filePath}\n` +
        "Please run: pnpm supabase:types\n" +
        "Make sure Supabase is running: pnpm supabase:start"
    );
  }

  const stats = fs.statSync(filePath);
  if (!stats.isFile()) {
    throw new Error(`Path is not a file: ${filePath}`);
  }

  // Check if file is readable and has content
  const content = fs.readFileSync(filePath, "utf8");
  if (content.length === 0) {
    throw new Error(`Database types file is empty: ${filePath}`);
  }

  if (!content.includes("Database") || !content.includes("Tables")) {
    throw new Error(
      `Invalid database types file: ${filePath}\n` +
        "File does not contain expected Database and Tables interfaces"
    );
  }
}

/**
 * Main execution function
 */
async function main(): Promise<void> {
  const config = DEFAULT_CONFIG;

  console.log("üîç Generating entity types from Supabase database schema...\n");

  try {
    // Validate input file
    console.log(`üìÅ Reading: ${path.relative(process.cwd(), config.databaseTypesPath)}`);
    validateDatabaseTypesFile(config.databaseTypesPath);

    // Read and parse the database types file
    const content = fs.readFileSync(config.databaseTypesPath, "utf8");
    const tableNames = extractTableNames(content);

    if (tableNames.length === 0) {
      console.log("‚ö†Ô∏è  No tables found in database schema");
      console.log("   This is normal if you haven't created any tables yet");
      console.log("   Run migrations first: pnpm supabase:reset\n");
      return;
    }

    console.log(`üìä Found ${tableNames.length} tables:`);
    console.log(`   ${tableNames.join(", ")}\n`);

    // Generate the entity types content
    const entityContent = generateEntityTypesContent(tableNames, config);

    // Write the output file
    console.log(`üìù Writing: ${path.relative(process.cwd(), config.outputPath)}`);
    fs.writeFileSync(config.outputPath, entityContent);

    // Summary
    const typeCount =
      tableNames.length * (1 + (config.includeInsertTypes ? 1 : 0) + (config.includeUpdateTypes ? 1 : 0));
    console.log(`‚úÖ Generated ${typeCount} entity types successfully!\n`);

    console.log("üéØ Usage:");
    console.log(
      `   import { ${generateEntityName(tableNames[0], config.entitySuffix)}, ${generateEntityName(tableNames[1] || tableNames[0], config.entitySuffix)} } from '@/types/entity-types';`
    );
    if (tableNames.length > 0) {
      console.log(
        `   import { ${generateEntityName(tableNames[0])}Insert, ${generateEntityName(tableNames[0])}Update } from '@/types/entity-types';\n`
      );
    }

    console.log("üí° Next steps:");
    console.log("   1. Use entity types in your repositories");
    console.log("   2. Update mappers to use the generated types");
    console.log("   3. Run: pnpm check\n");
  } catch (error) {
    console.error("‚ùå Error generating entity types:");
    console.error(error instanceof Error ? error.message : String(error));
    process.exit(1);
  }
}

// Run the script if called directly
if (require.main === module) {
  main().catch(console.error);
}

export { main, generateEntityName, extractTableNames, type Config };

